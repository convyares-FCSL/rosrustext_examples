# Lesson 02 Breakdown: Publishers & Shared Interfaces

## Architecture: The Publisher Pattern

In Lesson 01, we had internal logic (logging a counter). In Lesson 02, we expose that data to the rest of the ROS 2 system using a **Publisher**.



We also introduce two production-grade concepts:
1.  **Custom Interfaces**: Using a specific message type (`MsgCount`) generated from a `.msg` file.
2.  **Shared Utilities**: Using helper libraries (`utils_cpp`) to centralize topic names and QoS settings.

## Code Walkthrough

### 1. The Header: Custom Types
We must include the header file generated from our `.msg` definition.

```cpp
// This header is auto-generated by rosidl_generator_cpp
#include "lesson_interfaces/msg/msg_count.hpp"

// ... inside class ...
// We specify the message type in the template: <lesson_interfaces::msg::MsgCount>
rclcpp::Publisher<lesson_interfaces::msg::MsgCount>::SharedPtr publisher_;

```

* **Type Safety**: Unlike Python, C++ enforces strong typing at compile time. If you try to publish a string to this publisher, the code will not compile.

### 2. Shared Configuration (`utils_cpp`)

Hardcoding strings like `"chatter"` or manually setting QoS depth is brittle. We use a shared C++ library to handle this.

```cpp
#include "utils_cpp/qos.hpp"
#include "utils_cpp/topics.hpp"

// ... inside setup_publisher ...

// 1. Get Topic Name
// topics::chatter(*this) returns the standardized topic string.
auto topic_name = topics::chatter(*this);

// 2. Get QoS Profile
// qos::telemetry(*this) returns a specific RMW QoS profile (Reliable/Volatile).
auto qos_profile = qos::telemetry(*this);

// 3. Create Publisher
publisher_ = this->create_publisher<MsgCount>(topic_name, qos_profile);

```

**Why `utils_cpp`?**

* **Consistency**: If we change the topic name in the utility library, every node (publisher and subscriber) updates automatically upon recompilation.
* **QoS Matching**: ROS 2 communication only works if QoS profiles are compatible. Using a shared helper ensures both sides use the same settings (e.g., Reliability).

### 3. The Timer & Publisher Logic

The flow of logic moves from the *Setup* phase to the *Runtime* phase.

1. **Setup (`setup_timer`)**: Reads the `timer_period_s` parameter, validates it, and registers the callback.
2. **Runtime (`on_tick`)**: The callback fires.

```cpp
void Lesson02Node::on_tick() {
  // 1. Update State
  ++tick_;

  // 2. Create Message Object
  // MsgCount is a struct generated from MsgCount.msg
  MsgCount msg;
  msg.count = tick_; // 'count' matches the field name in the .msg file

  // 3. Publish
  // Serializes the struct and sends it over the network.
  publisher_->publish(msg);
}

```

### 4. Memory Management (Smart Pointers)

Notice that we use `std::make_shared` in `main` and `SharedPtr` for member variables.

```cpp
auto node = std::make_shared<Lesson02Node>();
rclcpp::spin(node);

```

* ROS 2 C++ relies heavily on `std::shared_ptr`. The Executor needs shared ownership of the node to keep it alive during the spin loop. When `main` finishes or throws an exception, the `node` pointer goes out of scope, the reference count hits zero, and the destructor cleans up all publishers and timers automatically.
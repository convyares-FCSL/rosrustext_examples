# Rust Lessons

This directory contains ROS 2 lessons implemented in Rust, split into two distinct tracks based on their architectural role.

---

## 1. `1_rclrs` (Native ROS 2 Nodes)

These lessons use [rclrs](https://github.com/ros2-rust/ros2_rust), the native Rust client library.
This is the **primary track** for writing standard ROS 2 nodes in Rust.

* **Role**: A full peer in the ROS 2 graph.
* **Protocol**: Native **DDS** (Direct communication with C++/Python nodes).
* **Build System**: `colcon` (via `ament_cargo`) or `cargo`.
* **Run**: `ros2 run <package> <executable>`

### Developer Workflow
You can build these packages using `colcon` just like C++ nodes:

```bash
cd ~/ros2_ws_tutorial
colcon build --packages-select lesson_00_bootstrap_rclrs
```

### **Important: Custom Messages**

Rust build tools do not automatically find ROS 2 message definitions in the source tree. You must point to the **generated artifacts**.

1. **Generator**: The interface package (`lesson_interfaces`) MUST depend on `rosidl_generator_rs` in its `package.xml`.
2. **Dependency**: Your Rust node's `Cargo.toml` must depend on the **generated crate** in the `install/` directory, **NOT** the source directory.

```toml
[dependencies]
# Correct: Points to the artifacts generated by Colcon
lesson_interfaces = { path = "../../../../install/lesson_interfaces/share/lesson_interfaces/rust" }
```

<details>
<summary><strong>Deep Dive: The "Missing Crate" Issue & Partial Vendoring Fix</strong></summary>

### The Problem
`rosidl_generator_rs` (the tool that makes Rust code from `.msg` files) adds `builtin_interfaces` and `service_msgs` as dependencies in the generated `Cargo.toml`.
However, because these packages are part of the ROS 2 core (installed in `/opt/ros`), they **do not have corresponding Rust crates** available on crates.io or in the system source. This causes `cargo build` to fail because it cannot resolve them.

### The Fix
We use a **Partial Vendoring Strategy**:
1.  We created minimal "dummy" Rust crates for `builtin_interfaces` and `service_msgs` in `src/4_interfaces/vendor_dummy`.
2.  We patched the build script (`scripts/01_setup/build_interfaces.sh`) to inject **relative path dependencies** into the generated `Cargo.toml`.

**Result**:
When `lesson_interfaces` builds, it links against these local dummy crates instead of trying to find broken versions on the internet. This ensures the build is self-contained and reliable.
</details>

---

## 2. `2_rcllibrust` (Client/Bridge Library)

These lessons use `roslibrust`, a pure Rust client that connects to the ROS 2 network via **WebSockets**.

* **Role**: An external client or tool.
* **Protocol**: **JSON over WebSockets** (via `rosbridge_suite`).
* **Prerequisite**: You **MUST** have `rosbridge_server` running.
* **Build System**: `cargo` ONLY.
* **Ignored by Colcon**: These packages contain a `COLCON_IGNORE` file to prevent build failures in standard ROS workflows.

### Architectural Constraints

Because these nodes run outside the `colcon` environment:

1. **Manual Message Definition**: We cannot link against generated C++ types. We must define `serde` structs manually to match the ROS 2 JSON schema.
2. **Async/Tokio**: Unlike `rclcpp` (spin loops), `roslibrust` uses `async`/`await` and `tokio` tasks for execution.

### Running these lessons

You need two terminals:

```bash
# Terminal 1: Start the Bridge (The Gateway)
sudo apt install ros-jazzy-rosbridge-server
ros2 launch rosbridge_server rosbridge_websocket_launch.xml

```

```bash
# Terminal 2: Run the Rust Client
cd src/3_rust/2_rcllibrust/lesson_00_bootstrap
cargo run
```

---

## Comparison

The goal of this workspace is to demonstrate full feature parity between Rust, C++, and Python.

| Feature | **rclrs** | **roslibrust** |
| --- | --- | --- |
| **Role** | Full ROS 2 Node | Client / Bridge |
| **Protocol** | **Native DDS** (RMW) | **JSON** via `rosbridge` |
| **Dependency** | None (Peer-to-Peer) | `rosbridge_server` |
| **Execution** | `spin` (Executor) | `async` / `tokio` |
| **Messages** | Generated Bindings | Manual `serde` Structs |
| **Latency** | Low (Zero-copy capable) | High (Serialization + TCP) |

> **Trade-off**: `roslibrust` is ideal for lightweight tools or systems that cannot install the full ROS 2 stack (DDS), but it incurs higher latency due to JSON serialization.

---

## Lessons

1. **Lesson 00**: Bootstrap
Setup, cargo configuration, and basic logging.

2. **Lesson 01**: Event Loop

    **rclrs**: Timers and Executors.
    
    **roslibrust**: Async connection handling.

3. **Lesson 02**: Publishers

    **rclrs**: Strongly typed interfaces.

    **roslibrust**: Manual `serde` mapping and async publishing.

4. **Lesson 03**: Subscribers & System Verification

    **rclrs**: QoS compatibility, logic injection, and reset tolerance.

    **roslibrust**: Async Streams, state validation inside tasks, and bridge verification.
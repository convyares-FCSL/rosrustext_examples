# Rust Lessons

This directory contains ROS 2 lessons implemented in Rust, split into two distinct tracks based on their architectural role.

---

## 1. `1_rclrs` (Native ROS 2 Nodes)

These lessons use [rclrs](https://github.com/ros2-rust/ros2_rust), the native Rust client library.
This is the **primary track** for writing standard ROS 2 nodes in Rust.

* **Role**: A full peer in the ROS 2 graph.
* **Protocol**: Native **DDS** (Direct communication with C++/Python nodes).
* **Build System**: `colcon` (via `ament_cargo`) or `cargo`.
* **Run**: `ros2 run <package> <executable>`

### Developer Workflow
You can build these packages using `colcon` just like C++ nodes:

```bash
cd ~/ros2_ws_tutorial
colcon build --packages-select lesson_00_bootstrap_rclrs
```

### **Important: Custom Messages**

Rust build tools do not automatically find ROS 2 message definitions in the source tree. You must point to the **generated artifacts**.

1. **Generator**: The interface package (`lesson_interfaces`) MUST depend on `rosidl_generator_rs` in its `package.xml`.
2. **Dependency**: Your Rust node's `Cargo.toml` must depend on the **generated crate** in the `install/` directory, **NOT** the source directory.

```toml
[dependencies]
# Correct: Points to the artifacts generated by Colcon
lesson_interfaces = { path = "../../../../install/lesson_interfaces/share/lesson_interfaces/rust" }
```
---

<details>
<summary><strong>Deep Dive: Rust Interface Generation, the Cargo Failure, and the Local Overlay Fix</strong></summary>

### What Actually Broke

Rust message generation in ROS 2 fails **not** because of Cargo, nor because of ROS distributions, but because of a mismatch between **how ROS interface dependencies are modeled** and **how Cargo resolves crates**.

When `rosidl_generator_rs` generates Rust bindings for an interface package (for example `lesson_interfaces`), it produces a Rust crate with a `Cargo.toml`. That file includes dependencies on other ROS interface packages referenced by the `.msg`, `.srv`, or `.action` definitions.

For example:

```toml
[dependencies]
builtin_interfaces = "*"
service_msgs = "*"
```

This is where things go wrong.

### Why This Happens

In ROS 2, core interfaces such as:

* `builtin_interfaces`
* `service_msgs`
* `action_msgs`
* `unique_identifier_msgs`

are **system ROS packages**, typically provided by `/opt/ros/<distro>`.
They are *not* Rust crates published on crates.io.

However, `rosidl_generator_rs` historically assumes that interface dependencies can be expressed as **Cargo version dependencies**, which only works if those crates exist on crates.io.

They do not.

As a result:

* Cargo tries to resolve `builtin_interfaces = "*"` from crates.io
* crates.io contains **no valid published crate**
* Resolution fails (or worse: resolves a yanked placeholder version)
* Downstream Rust nodes fail to build even though the ROS graph itself is valid

This is why the failure appears suddenly and inconsistently — it depends on whether Cargo is forced to re-resolve dependencies.

### Why This Only Shows Up in Rust

C++ and Python never hit this problem because:

* C++ uses CMake + ament, not Cargo
* Python uses generated modules installed into the ROS environment
* Neither relies on a global version registry like crates.io

Rust does.

### The Correct Fix (Local Overlay Strategy)

The correct solution is **not** to pin fake versions, vendor dummy crates, or rely on `[patch.crates-io]`.

The correct solution is to acknowledge the truth:

> ROS interface crates are **workspace-local artifacts**, not published dependencies.

#### What We Do

1. **Overlay Core Interfaces Locally**

   We clone the ROS interface packages that Rust depends on into the workspace:

   ```
   src/4_interfaces/
   ├── builtin_interfaces
   ├── service_msgs
   ├── action_msgs
   ├── unique_identifier_msgs
   └── lesson_interfaces
   ```

2. **Enable Rust Generation Explicitly**

   Each interface package is patched to depend on:

   ```xml
   <build_depend>rosidl_generator_rs</build_depend>
   ```

   This ensures Rust bindings are generated alongside C++ and Python.

3. **Fix the Generator Output (The Key Change)**

   The `Cargo.toml.em` template in `rosidl_generator_rs` is modified so that **all interface dependencies are emitted as path dependencies**, not version dependencies.

   Example generated output:

   ```toml
   [dependencies]
   builtin_interfaces = { path = "../../../../builtin_interfaces/share/builtin_interfaces/rust" }
   service_msgs = { path = "../../../../service_msgs/share/service_msgs/rust" }
   ```

   This matches how the artifacts are actually produced by `colcon`.

4. **Rebuild Interfaces as a Unit**

   The `build_interfaces.sh` script builds:

   * `rosidl_generator_rs`
   * all core interfaces
   * `lesson_interfaces`

   as a single, coherent graph.

### Proof That This Is Correct

This is not a workaround — it is provably correct.

#### Cargo Resolution Proof (Offline)

With networking disabled:

```bash
export CARGO_NET_OFFLINE=true
cargo tree -i builtin_interfaces
```

Cargo resolves:

```
builtin_interfaces v2.0.3 (path: install/builtin_interfaces/share/builtin_interfaces/rust)
```

No crates.io access. No version resolution. No patches.

#### Generator Output Proof

Generated `install/lesson_interfaces/.../Cargo.toml` contains **only path-based dependencies** for ROS interfaces.

No `"*"` versions. No registry lookups.

#### System Stability

* Rebuilding interfaces invalidates Cargo.lock → still works
* Clean workspace builds → still works
* Offline builds → still works
* Downstream lessons remain untouched

### Why We Do NOT Use Dummy Crates or Cargo Patches

* Dummy crates hide structural errors
* `[patch.crates-io]` is global, fragile, and misleading
* Version pinning is meaningless for non-published crates

The overlay approach mirrors how ROS itself models interfaces: **locally generated artifacts, resolved by build system structure, not global registries**.

### Final Takeaway

Rust is not “second-class” in ROS — but it *is* stricter.

Once the generator is aligned with ROS’s actual interface model, Rust nodes behave exactly like C++ and Python peers, with full type safety and zero runtime hacks.

</details>

---


## 2. `2_rcllibrust` (Client/Bridge Library)

These lessons use `roslibrust`, a pure Rust client that connects to the ROS 2 network via **WebSockets**.

* **Role**: An external client or tool.
* **Protocol**: **JSON over WebSockets** (via `rosbridge_suite`).
* **Prerequisite**: You **MUST** have `rosbridge_server` running.
* **Build System**: `cargo` ONLY.
* **Ignored by Colcon**: These packages contain a `COLCON_IGNORE` file to prevent build failures in standard ROS workflows.

### Architectural Constraints

Because these nodes run outside the `colcon` environment:

1. **Manual Message Definition**: We cannot link against generated C++ types. We must define `serde` structs manually to match the ROS 2 JSON schema.
2. **Async/Tokio**: Unlike `rclcpp` (spin loops), `roslibrust` uses `async`/`await` and `tokio` tasks for execution.

### Running these lessons

You need two terminals:

```bash
# Terminal 1: Start the Bridge (The Gateway)
sudo apt install ros-jazzy-rosbridge-server
ros2 launch rosbridge_server rosbridge_websocket_launch.xml

```

```bash
# Terminal 2: Run the Rust Client
cd src/3_rust/2_rcllibrust/lesson_00_bootstrap
cargo run
```

---

## Comparison

The goal of this workspace is to demonstrate full feature parity between Rust, C++, and Python.

| Feature | **rclrs** | **roslibrust** |
| --- | --- | --- |
| **Role** | Full ROS 2 Node | Client / Bridge |
| **Protocol** | **Native DDS** (RMW) | **JSON** via `rosbridge` |
| **Dependency** | None (Peer-to-Peer) | `rosbridge_server` |
| **Execution** | `spin` (Executor) | `async` / `tokio` |
| **Messages** | Generated Bindings | Manual `serde` Structs |
| **Latency** | Low (Zero-copy capable) | High (Serialization + TCP) |

> **Trade-off**: `roslibrust` is ideal for lightweight tools or systems that cannot install the full ROS 2 stack (DDS), but it incurs higher latency due to JSON serialization.

---

## Lessons

1. **Lesson 00**: Bootstrap
Setup, cargo configuration, and basic logging.

2. **Lesson 01**: Event Loop

    **rclrs**: Timers and Executors.
    
    **roslibrust**: Async connection handling.

3. **Lesson 02**: Publishers

    **rclrs**: Strongly typed interfaces.

    **roslibrust**: Manual `serde` mapping and async publishing.

4. **Lesson 03**: Subscribers & System Verification

    **rclrs**: QoS compatibility, logic injection, and reset tolerance.

    **roslibrust**: Async Streams, state validation inside tasks, and bridge verification.
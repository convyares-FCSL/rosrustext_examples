### Lesson 05 – Parameters & Central Configuration

**Lesson 05 establishes configuration as a first-class system concern.**

This lesson revisits the existing publisher–subscriber pair and rebuilds it so that **all operational behaviour is driven by parameters**, not embedded in node code.

---

## The Vehicle

* A **publisher** emitting `MsgCount` on a telemetry topic.
* A **subscriber** validating the same stream.
* Both nodes consume the **same central configuration** and support **safe runtime updates**.

This is a continuation of Lessons 02–03, not a new example.

---

## The Source of Truth

* Central YAML files in `lesson_interfaces/config/`:

  * `topics_config.yaml`
  * `qos_config.yaml`
  * `services_config.yaml`

These files define:

* topic names
* QoS profiles and defaults
* service names

They are composed explicitly at startup via `--params-file`.
No launch files, no file discovery, no watchers.

---

## What the System Must Do

When Lesson 05 is running correctly:

* Nodes start using configuration supplied via YAML + ROS parameters.
* Effective configuration is visible via standard ROS tools.
* Supported parameters can be updated at runtime:

  * changes are validated
  * invalid updates are rejected
  * valid updates apply immediately and safely
* No node restart is required for supported updates.

---

## The New Concept: Configuration as a System

Lesson 05 moves from *“nodes accept parameters”* to *“configuration is deliberate and observable”*.

* **Not hardcoded**
  Topic names, QoS, rates, and behavioural limits are not embedded in code.

* **Validated**
  Parameters are checked before being applied.
  Bad values fail fast with explicit reasons.

* **Inspectable**
  Operators can query:

  * declared parameters
  * current effective values
  * transport behaviour (QoS)

* **Mutable (where supported)**
  Runtime updates modify behaviour without rebuilding the node.

---

## Architecture (As Implemented)

### Central YAML

* Shared across all languages.
* Loaded via ROS parameter mechanisms.
* No language-specific schema.

### Language Utilities

Thin adapters only:

* declare parameters
* apply defaults
* detect external overrides
* emit warnings when defaults are used unintentionally
* translate parameters into native types (QoS, strings, numbers)

Utilities do **not**:

* create ROS entities
* own resources
* manage lifecycle

### Node Code

Each node:

* declares parameters it owns
* applies configuration at startup
* registers parameter callbacks
* rebuilds ROS resources **only when required**

  * timers rebuilt on rate change
  * logic updated in place when possible

### Logic

Pure logic is isolated where it is:

* shared
* stateful
* meaningfully testable without ROS

Unit tests validate logic and parameter validation **without a ROS graph**.

---

## Artifacts Produced by Lesson 05

* A fully parameter-driven publisher.
* A fully parameter-driven subscriber.
* Runtime-safe parameter callbacks.
* Unit tests covering validation and stream logic.
* Clear operational workflow:

  * build
  * test
  * run
  * inspect
  * mutate

---

## What This Lesson Establishes

Lesson 05 is the pivot from *tutorial nodes* to *operational systems*.

After this lesson, configuration:

* is centralized
* is explicit
* can be reasoned about
* can be changed safely
* behaves consistently across languages

Later lessons will build on this foundation rather than revisiting it.
